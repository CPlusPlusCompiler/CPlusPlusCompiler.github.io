(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.ReactLazyData = {}, global.React));
}(this, (function (exports, react) { 'use strict';

  /* --------------------
   * is-it-type module
   * Entry point
   * ------------------*/
  function isBoolean(arg) {
    return isType('boolean', arg);
  }
  function isNull(arg) {
    return arg === null;
  }
  function isString(arg) {
    return isType('string', arg);
  }
  function isObject(arg) {
    return isType('object', arg) && !isNull(arg);
  }
  function isFunction(arg) {
    return isType('function', arg);
  }
  /*
   * Additional methods
   */
  // Strings

  function isEmptyString(arg) {
    return arg === '';
  }
  function isFullString(arg) {
    return isString(arg) && !isEmptyString(arg);
  } // Objects

  function isType(type, arg) {
    return getType(arg) === type;
  }
  /*
   * Helpers
   */

  function getType(arg) {
    return typeof arg;
  }

  var prefix = 'Invariant failed';
  function invariant(condition, message) {
      if (condition) {
          return;
      }
      throw new Error(prefix + ": " + (message || ''));
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  /* --------------------
   * react-async-ssr module
   * Symbols
   * ------------------*/

  // Exports

  var symbols = {
  	NO_SSR: '$_react-async-ssr/symbols.NO_SSR',
  	ABORT: '$_react-async-ssr/symbols.ABORT',
  	ON_MOUNT: '$_react-async-ssr/symbols.ON_MOUNT'
  };

  // Exports

  var symbols$1 = symbols;
  var symbols_1 = symbols$1.NO_SSR;
  var symbols_2 = symbols$1.ABORT;
  var symbols_3 = symbols$1.ON_MOUNT;

  var isPromise_1 = isPromise;

  function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
  }

  /* --------------------
   * react-lazy-data module
   * Constants
   * ------------------*/
  // Exports
  var IS_RESOURCE = '__react-lazy-data.IS_RESOURCE';
  var DEFAULT_CACHE_VAR = '__react-lazy-data.DATA_CACHE';

  // Load status

  var INACTIVE = 0,
      LOADING = 1,
      LOADED = 2,
      ERRORED = 3,
      ABORTED = 4; // Read status

  var NONE_CALLED = 0,
      READ_CALLED = 1,
      CHILD_CALLED = 2; // Valid prop types

  var PROP_TYPES = ['string', 'number', 'symbol']; // Exports

  var Resource = /*#__PURE__*/function () {
    function Resource(factory, req, cacheKey, context, parent) {
      var _this = this;

      this._factory = factory;
      this._req = req;
      this._cacheKey = cacheKey;
      this._context = context;
      this._parent = parent;
      this._status = parent ? LOADING : INACTIVE;
      this._readStatus = NONE_CALLED;
      this._isDisposed = false;
      this._abort = undefined;
      this._children = [];
      this._numUndisposedChildren = 0; // Create promise
      // Could make this a thenable which calls `.then()` callbacks synchronously
      // when `this._resolve()` called, to avoid an extra tick,
      // but I don't think it's worth the code bloat to save a microtick.

      var promise = new Promise(function (resolve) {
        _this._resolve = resolve;
      });
      promise[symbols_2] = this.dispose.bind(this);
      promise[symbols_3] = this._mounted.bind(this);
      if (factory._noSsr) promise[symbols_1] = true;
      this._value = promise;
    }

    var _proto = Resource.prototype;

    _proto._load = function _load() {
      var _this2 = this;

      // Pass to parent if exists
      var parent = this._parent;

      if (parent) {
        parent._load();

        return;
      } // Do not load if already loading or aborted


      if (this._status !== INACTIVE) return; // Execute fetch function
      // TODO Catch synchronously thrown errors in `fetchFn()`

      var fetchFn = this._factory._fetchFn;
      var promise = fetchFn(this._req);
      !isPromise_1(promise) ?  invariant(false, "Fetch function must return a promise - got " + promise)  : void 0; // Set loading status

      this._status = LOADING; // Record promise's abort handler if defined

      var abort = promise.abort;
      if (isFunction(abort)) this._abort = abort.bind(promise); // Update status when promise resolves

      promise.then(function (res) {
        return _this2._resolved(res);
      }, function (err) {
        return _this2._rejected(err);
      });
    };

    _proto._resolved = function _resolved(value) {
      if (this._status !== LOADING) return;

      this._resolvedThis(value);

      for (var _i2 = 0, _this$_children2 = this._children; _i2 < _this$_children2.length; _i2++) {
        var _this$_children2$_i = _this$_children2[_i2],
            child = _this$_children2$_i.child,
            prop = _this$_children2$_i.prop;

        this._resolveChild(child, prop);
      }
    };

    _proto._resolvedThis = function _resolvedThis(value) {
      this._status = LOADED;
      this._value = value;
      this._abort = undefined;

      this._resolve();
    };

    _proto._resolveChild = function _resolveChild(child, prop) {
      var value = this._value;

      if (prop !== undefined) {
        try {
          value = value[prop];
        } catch (err) {
          child._rejected(err);

          return;
        }
      }

      child._resolved(value);
    };

    _proto._rejected = function _rejected(err) {
      if (this._status !== LOADING) return;
      this._status = ERRORED;
      this._value = err;
      this._abort = undefined;

      this._resolve();

      for (var _i4 = 0, _this$_children4 = this._children; _i4 < _this$_children4.length; _i4++) {
        var child = _this$_children4[_i4].child;

        child._rejected(err);
      }
    };

    _proto.read = function read() {
      this._validateReadStatus(READ_CALLED);

      if (this._status === LOADED) return this._value;
      throw this._value;
    };

    _proto.dispose = function dispose() {
      if (this._isDisposed) return;
      this._isDisposed = true;
      var parent = this._parent;

      if (parent) {
        parent._disposeFromChild();
      } else {
        if ([INACTIVE, LOADING].includes(this._status)) {
          this._status = ABORTED;
          var abort = this._abort;

          if (abort) {
            this._abort = undefined;
            abort();
          }
        }

        var cacheKey = this._cacheKey;
        if (cacheKey !== undefined) this._factory._clearCacheEntry(cacheKey);
      }
    };

    _proto.child = function child(prop) {
      !PROP_TYPES.includes(typeof prop) ?  invariant(false, ".child() must be passed a string, number or symbol - received " + prop)  : void 0;
      return this._child(prop);
    };

    _proto.clone = function clone() {
      return this._child();
    };

    _proto._child = function _child(prop) {
      return this._childWithContext(prop, this._context);
    };

    _proto._childWithContext = function _childWithContext(prop, context) {
      this._validateReadStatus(CHILD_CALLED);

      var child = new Resource(this._factory, this._req, this._cacheKey, context, this);
      var status = this._status;

      if (status === LOADED) {
        this._resolveChild(child, prop);
      } else if (status === ERRORED) {
        child._rejected(this._value);
      }

      this._children.push({
        child: child,
        prop: prop
      });

      this._numUndisposedChildren++;
      return child;
    };

    _proto._disposeFromChild = function _disposeFromChild() {
      this._numUndisposedChildren--;
      if (this._numUndisposedChildren === 0) this.dispose();
    };

    _proto._validateReadStatus = function _validateReadStatus(newReadStatus) {
      var readStatus = this._readStatus;

      if (readStatus === NONE_CALLED) {
        this._readStatus = newReadStatus;
      } else if (readStatus !== newReadStatus) {
          invariant(false, 'Cannot call both .read() and .child() / .clone() on a resource')  ;
      }
    };

    _proto._mounted = function _mounted(willRender) {
      var context = this._context;
      if (context) context.register(this, willRender);
    };

    _createClass(Resource, [{
      key: "isLoading",
      get: function get() {
        return [INACTIVE, LOADING, ABORTED].includes(this._status);
      }
    }, {
      key: "isLoaded",
      get: function get() {
        return this._status === LOADED;
      }
    }, {
      key: "isErrored",
      get: function get() {
        return this._status === ERRORED;
      }
    }]);

    return Resource;
  }();
  Resource.prototype[IS_RESOURCE] = true;

  /* --------------------
   * react-lazy-data module
   * Server context
   * ------------------*/

  var ServerContext = react.createContext();

  /* --------------------
   * react-lazy-data module
   * Shared functions
   * ------------------*/

  var EMPTY_OBJECT = {}; // Exports

  function getCacheVarFromOptionsWithValidate(options, defaultValue) {
    if (options == null) {
      options = EMPTY_OBJECT;
    } else {
      validateOptions(options);
    }

    return getCacheVarFromOptions(options, defaultValue);
  }
  function validateOptions(options) {
    !isObject(options) ?  invariant(false, "options must be an object if provided - got " + options)  : void 0;
  }
  function getCacheVarFromOptions(options, defaultValue) {
    var cacheVar = options.cacheVar;
    if (cacheVar == null) return defaultValue || DEFAULT_CACHE_VAR;
    !isFullString(cacheVar) ?  invariant(false, "options.cacheVar must be a non-empty string if provided - got " + cacheVar)  : void 0;
    return cacheVar;
  }

  /* --------------------
   * react-lazy-data module
   * `createResourceFactory()` function
   * ------------------*/

  var IS_NODE = typeof window === 'undefined'; // Exports

  var ResourceFactory = /*#__PURE__*/function () {
    function ResourceFactory(fetchFn, options) {
      this._fetchFn = fetchFn; // Validate and conform options

      var id, serialize, noSsr, cacheVar;

      if (options != null) {
        validateOptions(options);
        id = options.id;
        serialize = options.serialize;
        noSsr = options.noSsr;

        // Validate and conform `id` option
        if (id == null) {
          id = undefined;
        } else {
          !isFullString(id) ?  invariant(false, "options.id must be a non-empty string if provided - got " + id)  : void 0; // Using global cache implies serialization

          if (serialize == null) {
            serialize = true;
          } else {
            !(serialize !== false) ?  invariant(false, 'serialization cannot be disabled when using global cache')  : void 0;
          } // Get cache var from options (use default cache var if not provided)


          cacheVar = getCacheVarFromOptions(options);
        } // Validate and conform `serialize` option


        if (serialize == null || serialize === false) {
          serialize = undefined;
        } else if (serialize === true) {
          serialize = JSON.stringify;
        } else {
          !isFunction(serialize) ?  invariant(false, "options.serialize must be a function or boolean if provided - got " + serialize)  : void 0;
          serialize = wrapSerializer(serialize);
        }

        !(!IS_NODE || !serialize || id) ?  invariant(false, 'If using caching on server side, must also provide options.id')  : void 0; // Validate and conform `noSsr` option

        if (noSsr == null) {
          noSsr = false;
        } else {
          !isBoolean(noSsr) ?  invariant(false, "options.noSsr must be a boolean if provided - got " + noSsr)  : void 0; // No-SSR mode is only enabled on server side

          if (!IS_NODE) noSsr = false;
        }
      } else {
        noSsr = false;
      }

      this._id = id;
      this._serialize = serialize;
      this._noSsr = noSsr;
      this._cacheVar = cacheVar; // Init cache
      // Cache cannot be stored on factory in SSR as the factory is static across different
      // renders, so data would cross between renders. So it is stored in context instead
      // when rendering on server side.

      if (IS_NODE) {
        this._cache = undefined;
        this._needContext = !!serialize;
      } else {
        this._cache = serialize ? {} : undefined;
        this._needContext = false;
      }
    }

    var _proto = ResourceFactory.prototype;

    _proto.create = function create(req) {
      !!this._needContext ?  invariant(false, '`.create` cannot be used on server side with caching enabled')  : void 0;
      return this._create(req);
    };

    _proto._create = function _create(req, context) {
      var resource = this._getResource(req, undefined, context); // Load resource immediately
      // (unless in no-SSR mode, in which case leave it pending forever)


      if (!this._noSsr) resource._load();
      return resource;
    };

    _proto.use = function use(req) {
      // If server-side render, load immediately with context
      if (IS_NODE) {
        var context = react.useContext(ServerContext);
        !(context || !this._needContext) ?  invariant(false, 'Application must be wrapped in a `DataExtractorManager` when using caching on server side')  : void 0;
        return this._create(req, context);
      } // If no existing resource or req has changed, create one


      var resourceRef = react.useRef();
      var resource = resourceRef.current;

      if (!resource || req !== resource._req) {
        // TODO Add `if (resource) resource.dispose();` here to abort faster?
        resource = this._getResource(req, resource);
        resourceRef.current = resource;
      } // On mount, load data


      react.useEffect(function () {
        resource._load(); // On unmount, dispose resource


        return function () {
          return resource.dispose();
        };
      }, [resource]); // Return resource

      return resource;
    };

    _proto._getResource = function _getResource(req, previousResource, context) {
      // If no cache, create new resource without caching
      var serialize = this._serialize;
      if (!serialize) return new Resource(this, req, undefined, context); // Serialize request

      var cacheKey = serialize(req); // If serialized request has not changed, return previous resource

      if (previousResource && previousResource._cacheKey === cacheKey) return previousResource; // Get existing resource from cache
      // Cache is either in factory or (on server side) in context

      var cache = context ? context.getCache(this) : this._cache;
      var masterResource = cache[cacheKey]; // If not found in cache, create resource and add to cache

      if (!masterResource) {
        // Create new resource
        masterResource = new Resource(this, req, cacheKey); // Get data from global cache

        this._populateFromGlobalCache(masterResource, cacheKey); // Save resource to local cache


        cache[cacheKey] = masterResource;
      } // Return clone of master resource


      return masterResource._childWithContext(undefined, context);
    };

    _proto._clearCacheEntry = function _clearCacheEntry(cacheKey) {
      if (this._cache) delete this._cache[cacheKey];
    }
    /**
     * Get data from global cache and resolve resource with it.
     *
     * The global cache is one shot - values are consumed from it, and then removed from
     * the cache. So next time the same request is made, it will async fetch fresh data.
     * Global cache is intended for SSR hyration. At the end of hydration, the cache should
     * be empty.
     *
     * @param {Object} resource - Resource to populate with data if found in cache
     * @param {string} cacheKey - Request cache key
     * @returns {undefined}
     */
    ;

    _proto._populateFromGlobalCache = function _populateFromGlobalCache(resource, cacheKey) {
      // Global cache only works on client-side
      if (IS_NODE) return; // If no factory ID, does not use global cache

      var id = this._id;
      if (!id) return; // Get global cache

      var globalCacheContainer = window[this._cacheVar];
      if (!globalCacheContainer) return;
      var globalCache = globalCacheContainer.data;
      if (!globalCache) return; // Get data cache for this factory

      var valuesCache = globalCache[id];
      if (!valuesCache) return; // Get data cached for this request
      // NB `.hasOwnProperty()` is safe here as we know the cache object is a plain JS object

      if (!valuesCache.hasOwnProperty(cacheKey)) return; // eslint-disable-line no-prototype-builtins

      var value = valuesCache[cacheKey]; // Delete from global cache

      delete valuesCache[cacheKey];
      if (Object.keys(valuesCache).length === 0) delete globalCache[id]; // Resolve resource with cached data

      resource._resolvedThis(value);
    };

    return ResourceFactory;
  }();

  function createResourceFactory(fetchFn, options) {
    return new ResourceFactory(fetchFn, options);
  }
  /*
   * Helper functions
   */

  function wrapSerializer(serialize) {
    return function (req) {
      var cacheKey = serialize(req);
      !isString(cacheKey) ?  invariant(false, "serialize() must return a string - got " + cacheKey)  : void 0;
      return cacheKey;
    };
  }

  /* --------------------
   * is-class-component module
   * Entry point
   * ------------------*/

  /**
   * Determine if input is a React class component.
   * Input must have already been checked that it's a function before calling this.
   * @param {Function} Component - Function
   * @return {boolean} - true if is a React class component
   */

  function isClassComponent(input) {
    return isFunction(input) && !!(input.prototype && input.prototype.isReactComponent);
  }

  /* --------------------
   * is-class-component module
   * ESM Entry point
   * ------------------*/

  /* --------------------
   * react-lazy-data module
   * `isResource()` function
   * ------------------*/

  function isResource(value) {
    return value != null && !!value[IS_RESOURCE] && isFunction(value.read);
  }

  function withResources(Component) {
    !isFunction(Component) ?  invariant(false, "withResources() must be passed a React component - got " + Component)  : void 0;
    var ComponentWithResources = isClassComponent(Component) ? wrapClassComponent(Component) : wrapFunctionComponent(Component);
    Object.assign(ComponentWithResources, Component);
    ComponentWithResources.displayName = "withResources(" + (Component.displayName || Component.name || '') + ")";
    return ComponentWithResources;
  }

  function wrapFunctionComponent(Component) {
    return function (props) {
      props = processProps(props);

      for (var _len = arguments.length, otherArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        otherArgs[_key - 1] = arguments[_key];
      }

      return Component.call.apply(Component, [this, props].concat(otherArgs)); // eslint-disable-line no-invalid-this
    };
  }

  function wrapClassComponent(Component) {
    return function (props) {
      props = processProps(props);
      return react.createElement(Component, props);
    };
  }

  function processProps(props) {
    props = _extends({}, props);

    for (var key in props) {
      var value = props[key];
      if (isResource(value)) props[key] = value.read();
    }

    return props;
  }

  /* --------------------
   * react-lazy-data module
   * `preloadData()` function
   * ------------------*/

  function preloadData(options) {
    return new Promise(function (resolve) {
      // Get cache var from options
      // NB This is inside promise so function never synchronously throws
      var cacheVar = getCacheVarFromOptionsWithValidate(options);
      var cacheContainer = window[cacheVar]; // If data already present, resolve

      if (cacheContainer) {
        resolve(cacheContainer.data);
        return;
      } // Set up trap to catch when data is written.
      // When it is, resolve promise.


      cacheContainer = Object.create(null, {
        data: {
          configurable: true,
          set: function set(data) {
            Object.defineProperty(cacheContainer, 'data', {
              value: data
            });
            resolve(data);
          }
        }
      });
      window[cacheVar] = cacheContainer;
    });
  }

  exports.createResourceFactory = createResourceFactory;
  exports.isResource = isResource;
  exports.preloadData = preloadData;
  exports.withResources = withResources;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
